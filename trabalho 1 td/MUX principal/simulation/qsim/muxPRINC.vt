// Copyright (C) 1991-2013 Altera Corporation
// Your use of Altera Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Altera Program License 
// Subscription Agreement, Altera MegaCore Function License 
// Agreement, or other applicable license agreement, including, 
// without limitation, that your use is for the sole purpose of 
// programming logic devices manufactured by Altera and sold by 
// Altera or its authorized distributors.  Please refer to the 
// applicable agreement for further details.

// *****************************************************************************
// This file contains a Verilog test bench with test vectors .The test vectors  
// are exported from a vector file in the Quartus Waveform Editor and apply to  
// the top level entity of the current Quartus project .The user can use this   
// testbench to simulate his design using a third-party simulation tool .       
// *****************************************************************************
// Generated on "03/25/2023 13:56:48"
                                                                        
// Verilog Self-Checking Test Bench (with test vectors) for design :    muxPRINC
// 
// Simulation tool : 3rd Party
// 

`timescale 1 ps/ 1 ps
module muxPRINC_vlg_sample_tst(
	in01,
	in02,
	in03,
	in04,
	in05,
	in06,
	in07,
	in08,
	in09,
	in10,
	in11,
	in12,
	in13,
	in14,
	in15,
	in16,
	sinal,
	sampler_tx
);
input [3:0] in01;
input [3:0] in02;
input [3:0] in03;
input [3:0] in04;
input [3:0] in05;
input [3:0] in06;
input [3:0] in07;
input [3:0] in08;
input [3:0] in09;
input [3:0] in10;
input [3:0] in11;
input [3:0] in12;
input [3:0] in13;
input [3:0] in14;
input [3:0] in15;
input [3:0] in16;
input [3:0] sinal;
output sampler_tx;

reg sample;
time current_time;
always @(in01 or in02 or in03 or in04 or in05 or in06 or in07 or in08 or in09 or in10 or in11 or in12 or in13 or in14 or in15 or in16 or sinal)
                                                                                
begin                                                 
 if ($realtime > 0)                                   
 begin                                                
	if ($realtime == 0 || $realtime != current_time)  
	begin									          
		if (sample === 1'bx)                          
			sample = 0;                               
		else                                          
			sample = ~sample;                         
	end										          
	current_time = $realtime;					      
 end                                                  
end                                                   

assign sampler_tx = sample;
endmodule

module muxPRINC_vlg_check_tst (
	saidamux,
	sampler_rx
);
input [3:0] saidamux;
input sampler_rx;

reg [3:0] saidamux_expected;

reg [3:0] saidamux_prev;

reg [3:0] saidamux_expected_prev;

reg [3:0] last_saidamux_exp;

reg trigger;

integer i;
integer nummismatches;

reg [1:1] on_first_change ;


initial
begin
trigger = 0;
i = 0;
nummismatches = 0;
on_first_change = 1'b1;
end

// update real /o prevs

always @(trigger)
begin
	saidamux_prev = saidamux;
end

// update expected /o prevs

always @(trigger)
begin
	saidamux_expected_prev = saidamux_expected;
end


// expected saidamux[ 3 ]
initial
begin
	saidamux_expected[3] = 1'bX;
end 
// expected saidamux[ 2 ]
initial
begin
	saidamux_expected[2] = 1'bX;
end 
// expected saidamux[ 1 ]
initial
begin
	saidamux_expected[1] = 1'bX;
end 
// expected saidamux[ 0 ]
initial
begin
	saidamux_expected[0] = 1'bX;
end 
// generate trigger
always @(saidamux_expected or saidamux)
begin
	trigger <= ~trigger;
end

always @(posedge sampler_rx or negedge sampler_rx)
begin
`ifdef debug_tbench
	$display("Scanning pattern %d @time = %t",i,$realtime );
	i = i + 1;
	$display("| expected saidamux = %b | ",saidamux_expected_prev);
	$display("| real saidamux = %b | ",saidamux_prev);
`endif
	if (
		( saidamux_expected_prev[0] !== 1'bx ) && ( saidamux_prev[0] !== saidamux_expected_prev[0] )
		&& ((saidamux_expected_prev[0] !== last_saidamux_exp[0]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port saidamux[0] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", saidamux_expected_prev);
		$display ("     Real value = %b", saidamux_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_saidamux_exp[0] = saidamux_expected_prev[0];
	end
	if (
		( saidamux_expected_prev[1] !== 1'bx ) && ( saidamux_prev[1] !== saidamux_expected_prev[1] )
		&& ((saidamux_expected_prev[1] !== last_saidamux_exp[1]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port saidamux[1] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", saidamux_expected_prev);
		$display ("     Real value = %b", saidamux_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_saidamux_exp[1] = saidamux_expected_prev[1];
	end
	if (
		( saidamux_expected_prev[2] !== 1'bx ) && ( saidamux_prev[2] !== saidamux_expected_prev[2] )
		&& ((saidamux_expected_prev[2] !== last_saidamux_exp[2]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port saidamux[2] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", saidamux_expected_prev);
		$display ("     Real value = %b", saidamux_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_saidamux_exp[2] = saidamux_expected_prev[2];
	end
	if (
		( saidamux_expected_prev[3] !== 1'bx ) && ( saidamux_prev[3] !== saidamux_expected_prev[3] )
		&& ((saidamux_expected_prev[3] !== last_saidamux_exp[3]) ||
			on_first_change[1])
	)
	begin
		$display ("ERROR! Vector Mismatch for output port saidamux[3] :: @time = %t",  $realtime);
		$display ("     Expected value = %b", saidamux_expected_prev);
		$display ("     Real value = %b", saidamux_prev);
		nummismatches = nummismatches + 1;
		on_first_change[1] = 1'b0;
		last_saidamux_exp[3] = saidamux_expected_prev[3];
	end

	trigger <= ~trigger;
end
initial 

begin 
$timeformat(-12,3," ps",6);
#1000000;
if (nummismatches > 0)
	$display ("%d mismatched vectors : Simulation failed !",nummismatches);
else
	$display ("Simulation passed !");
$finish;
end 
endmodule

module muxPRINC_vlg_vec_tst();
// constants                                           
// general purpose registers
reg [3:0] in01;
reg [3:0] in02;
reg [3:0] in03;
reg [3:0] in04;
reg [3:0] in05;
reg [3:0] in06;
reg [3:0] in07;
reg [3:0] in08;
reg [3:0] in09;
reg [3:0] in10;
reg [3:0] in11;
reg [3:0] in12;
reg [3:0] in13;
reg [3:0] in14;
reg [3:0] in15;
reg [3:0] in16;
reg [3:0] sinal;
// wires                                               
wire [3:0] saidamux;

wire sampler;                             

// assign statements (if any)                          
muxPRINC i1 (
// port map - connection between master ports and signals/registers   
	.in01(in01),
	.in02(in02),
	.in03(in03),
	.in04(in04),
	.in05(in05),
	.in06(in06),
	.in07(in07),
	.in08(in08),
	.in09(in09),
	.in10(in10),
	.in11(in11),
	.in12(in12),
	.in13(in13),
	.in14(in14),
	.in15(in15),
	.in16(in16),
	.saidamux(saidamux),
	.sinal(sinal)
);
// in01[ 3 ]
initial
begin
	repeat(2)
	begin
		in01[3] = 1'b0;
		in01[3] = #200000 1'b1;
		# 200000;
	end
	in01[3] = 1'b0;
end 
// in01[ 2 ]
always
begin
	in01[2] = 1'b0;
	in01[2] = #100000 1'b1;
	#100000;
end 
// in01[ 1 ]
always
begin
	in01[1] = 1'b0;
	in01[1] = #50000 1'b1;
	#50000;
end 
// in01[ 0 ]
always
begin
	in01[0] = 1'b0;
	in01[0] = #25000 1'b1;
	#25000;
end 
// in02[ 3 ]
initial
begin
	repeat(2)
	begin
		in02[3] = 1'b0;
		in02[3] = #200000 1'b1;
		# 200000;
	end
	in02[3] = 1'b0;
end 
// in02[ 2 ]
initial
begin
	in02[2] = 1'b0;
end 
// in02[ 1 ]
always
begin
	in02[1] = 1'b0;
	in02[1] = #100000 1'b1;
	#100000;
end 
// in02[ 0 ]
always
begin
	in02[0] = 1'b0;
	in02[0] = #50000 1'b1;
	#50000;
end 
// in03[ 3 ]
initial
begin
	in03[3] = 1'b1;
end 
// in03[ 2 ]
initial
begin
	in03[2] = 1'b1;
end 
// in03[ 1 ]
initial
begin
	in03[1] = 1'b1;
end 
// in03[ 0 ]
initial
begin
	in03[0] = 1'b1;
end 
// in04[ 3 ]
initial
begin
	in04[3] = 1'b0;
end 
// in04[ 2 ]
initial
begin
	in04[2] = 1'b0;
end 
// in04[ 1 ]
initial
begin
	in04[1] = 1'b0;
end 
// in04[ 0 ]
initial
begin
	in04[0] = 1'b0;
end 
// in05[ 3 ]
initial
begin
	in05[3] = 1'bX;
end 
// in05[ 2 ]
initial
begin
	in05[2] = 1'bX;
end 
// in05[ 1 ]
initial
begin
	in05[1] = 1'bX;
end 
// in05[ 0 ]
initial
begin
	in05[0] = 1'bX;
end 
// in06[ 3 ]
initial
begin
	in06[3] = 1'bZ;
end 
// in06[ 2 ]
initial
begin
	in06[2] = 1'bZ;
end 
// in06[ 1 ]
initial
begin
	in06[1] = 1'bZ;
end 
// in06[ 0 ]
initial
begin
	in06[0] = 1'bZ;
end 
// in07[ 3 ]
initial
begin
	in07[3] = 1'b1;
end 
// in07[ 2 ]
initial
begin
	in07[2] = 1'b1;
end 
// in07[ 1 ]
initial
begin
	in07[1] = 1'b1;
end 
// in07[ 0 ]
initial
begin
	in07[0] = 1'b1;
end 
// in08[ 3 ]
initial
begin
	in08[3] = 1'b0;
end 
// in08[ 2 ]
initial
begin
	in08[2] = 1'b0;
end 
// in08[ 1 ]
initial
begin
	in08[1] = 1'b0;
end 
// in08[ 0 ]
initial
begin
	in08[0] = 1'b0;
end 
// in09[ 3 ]
initial
begin
	in09[3] = 1'b1;
end 
// in09[ 2 ]
initial
begin
	in09[2] = 1'b1;
end 
// in09[ 1 ]
initial
begin
	in09[1] = 1'b1;
end 
// in09[ 0 ]
initial
begin
	in09[0] = 1'b1;
end 
// in10[ 3 ]
initial
begin
	in10[3] = 1'bX;
end 
// in10[ 2 ]
initial
begin
	in10[2] = 1'bX;
end 
// in10[ 1 ]
initial
begin
	in10[1] = 1'bX;
end 
// in10[ 0 ]
initial
begin
	in10[0] = 1'bX;
end 
// in11[ 3 ]
initial
begin
	in11[3] = 1'bZ;
end 
// in11[ 2 ]
initial
begin
	in11[2] = 1'bZ;
end 
// in11[ 1 ]
initial
begin
	in11[1] = 1'bZ;
end 
// in11[ 0 ]
initial
begin
	in11[0] = 1'bZ;
end 
// in12[ 3 ]
initial
begin
	in12[3] = 1'b1;
end 
// in12[ 2 ]
initial
begin
	in12[2] = 1'b1;
end 
// in12[ 1 ]
initial
begin
	in12[1] = 1'b1;
end 
// in12[ 0 ]
initial
begin
	in12[0] = 1'b1;
end 
// in13[ 3 ]
initial
begin
	in13[3] = 1'b0;
end 
// in13[ 2 ]
initial
begin
	in13[2] = 1'b0;
end 
// in13[ 1 ]
initial
begin
	in13[1] = 1'b0;
end 
// in13[ 0 ]
initial
begin
	in13[0] = 1'b0;
end 
// in14[ 3 ]
initial
begin
	in14[3] = 1'bZ;
end 
// in14[ 2 ]
initial
begin
	in14[2] = 1'bZ;
end 
// in14[ 1 ]
initial
begin
	in14[1] = 1'bZ;
end 
// in14[ 0 ]
initial
begin
	in14[0] = 1'bZ;
end 
// in15[ 3 ]
initial
begin
	in15[3] = 1'b0;
end 
// in15[ 2 ]
initial
begin
	in15[2] = 1'b0;
end 
// in15[ 1 ]
initial
begin
	in15[1] = 1'b0;
end 
// in15[ 0 ]
initial
begin
	in15[0] = 1'b0;
end 
// in16[ 3 ]
initial
begin
	in16[3] = 1'bX;
end 
// in16[ 2 ]
initial
begin
	in16[2] = 1'bX;
end 
// in16[ 1 ]
initial
begin
	in16[1] = 1'bX;
end 
// in16[ 0 ]
initial
begin
	in16[0] = 1'bX;
end 
// sinal[ 3 ]
initial
begin
	sinal[3] = 1'b0;
end 
// sinal[ 2 ]
initial
begin
	sinal[2] = 1'b0;
end 
// sinal[ 1 ]
initial
begin
	sinal[1] = 1'b0;
end 
// sinal[ 0 ]
initial
begin
	sinal[0] = 1'b0;
end 

muxPRINC_vlg_sample_tst tb_sample (
	.in01(in01),
	.in02(in02),
	.in03(in03),
	.in04(in04),
	.in05(in05),
	.in06(in06),
	.in07(in07),
	.in08(in08),
	.in09(in09),
	.in10(in10),
	.in11(in11),
	.in12(in12),
	.in13(in13),
	.in14(in14),
	.in15(in15),
	.in16(in16),
	.sinal(sinal),
	.sampler_tx(sampler)
);

muxPRINC_vlg_check_tst tb_out(
	.saidamux(saidamux),
	.sampler_rx(sampler)
);
endmodule

